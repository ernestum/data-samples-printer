{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Data Samples Printer","text":"<p>Documentation: https://ernestum.github.io/data-samples-printer</p> <p>Source Code: https://github.com/ernestum/data-samples-printer</p> <p>PyPI: https://pypi.org/project/data-samples-printer/</p> <p>Don't be just mean and standart, print histograms as unicode instead!</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install data-samples-printer\n</code></pre>"},{"location":"#basic-usage","title":"Basic Usage","text":"<pre><code>import data_samples_printer as dsp\nimport numpy as np\n\ns1 = np.random.normal(size=100)\ns2 = np.random.normal(size=100, scale=0.2)\n\n# Plain printing\ndsp.print(s1)\n&gt; \u2581   \u2583 \u2581\u2583\u2581  \u2583\u2583\u2585\u2587\u2585\u2588\u2584\u2584\u2584\u2587\u2583\u2583\u2588\u2584\u2585\u2587\u2584\u2583\u2583\u2581\u2588\u2585\u2588 \u2581\u2583\u2583\u2581\u2583\u2581        \u2581\n\n# Printing multiple samples aligns their range\ndsp.print(s1, s2)\n&gt; \u2581   \u2583 \u2581\u2583\u2581  \u2583\u2583\u2585\u2587\u2585\u2588\u2584\u2584\u2584\u2587\u2583\u2583\u2588\u2584\u2585\u2587\u2584\u2583\u2583\u2581\u2588\u2585\u2588 \u2581\u2583\u2583\u2581\u2583\u2581        \u2581\n&gt;                   \u2581\u2582\u2583\u2588\u2584\u2585\u2583\u2582\u2581\n\n# Printing with labels\ndsp.print(normal=s1, squeezed=s2)\n&gt; \u2581   \u2583 \u2581\u2583\u2581  \u2583\u2583\u2585\u2587\u2585\u2588\u2584\u2584\u2584\u2587\u2583\u2583\u2588\u2584\u2585\u2587\u2584\u2583\u2583\u2581\u2588\u2585\u2588 \u2581\u2583\u2583\u2581\u2583\u2581        \u2581 normal\n&gt;                    \u2581\u2582\u2583\u2588\u2584\u2585\u2583\u2582\u2581                       squeezed\n\n# Pretty printing\ndsp.pprint(s1, s2)\n&gt; \u2582 \u2582\u2581\u2581 \u2581\u2582\u2584\u2583\u2581\u2581\u2582\u2582\u2582\u2584\u2583\u2582\u2588\u2583\u2583\u2582\u2583\u2582\u2582\u2582\u2581\u2583\u2582\u2584\u2583\u2582 \u2581\u2582\u2581 \u2581\u2581\u2582       \u2581 \u2581 0.00 \u00b11.00\n&gt;                 \u2581\u2582\u2583\u2586\u2588\u2585\u2586\u2584\u2581                          0.04 \u00b10.20\n\ndsp.mprint(normal=s1, squeezed=s2)\n&gt; dist | mean | std | name\n&gt; -----|------|-----|-----\n&gt; `\u2595\u2581 \u2582\u2581\u2581\u2581\u2581\u2581\u2583\u2581 \u2582\u2586\u2582\u2581\u2585\u2585\u2585\u2588\u2582\u2585\u2583\u2585\u2588\u2583\u2587\u2586\u2582\u2582\u2582\u2582\u2582\u2582\u2585\u2583\u2581 \u2581     \u2581   \u2582 \u2581\u258f` | -0.04 | \u00b10.85 | normal\n&gt; `\u2595                \u2581 \u2581\u2584\u2583\u2588\u2586\u2588\u2586\u2582\u2582                       \u258f` | 0.01 | \u00b10.19 | squeezed\n&gt; `\u2595-1.93                                         2.41\u258f` |\n</code></pre> <p>renders as:</p> dist mean std name <code>\u2595\u2581 \u2582\u2581\u2581\u2581\u2581\u2581\u2583\u2581 \u2582\u2586\u2582\u2581\u2585\u2585\u2585\u2588\u2582\u2585\u2583\u2585\u2588\u2583\u2587\u2586\u2582\u2582\u2582\u2582\u2582\u2582\u2585\u2583\u2581 \u2581     \u2581   \u2582 \u2581\u258f</code> -0.04 \u00b10.85 normal <code>\u2595                \u2581 \u2581\u2584\u2583\u2588\u2586\u2588\u2586\u2582\u2582                       \u258f</code> 0.01 \u00b10.19 squeezed <code>\u2595-1.93                                         2.41\u258f</code>"},{"location":"#development","title":"Development","text":"<ul> <li>Clone this repository</li> <li>Requirements:</li> <li>Poetry</li> <li>Python 3.7+</li> <li>Create a virtual environment and install the dependencies</li> </ul> <pre><code>poetry install\n</code></pre> <ul> <li>Activate the virtual environment</li> </ul> <pre><code>poetry shell\n</code></pre>"},{"location":"#testing","title":"Testing","text":"<pre><code>pytest\n</code></pre>"},{"location":"#documentation","title":"Documentation","text":"<p>The documentation is automatically generated from the content of the docs directory and from the docstrings  of the public signatures of the source code. The documentation is updated and published as a Github project page   automatically as part each release.</p>"},{"location":"#releasing","title":"Releasing","text":"<p>To make a new release:</p> <pre><code>poetry version &lt;major|minor|patch&gt;  # Update the version number\npoetry run kacl-cli release &lt;new release number&gt; --modify --auto-link  # Update the changelog\ngit add CHANGELOG.md pyproject.toml\ngit commit -m \"Release &lt;new release number&gt;\"\ngit tag &lt;new release number&gt;\ngit push origin &lt;new release number&gt;\n</code></pre> <p>Then create a new release on GitHub with the output of:</p> <pre><code>poetry run kacl-cli get &lt;new release number&gt; \n</code></pre> <p>GitHub releases and publish it. When  a release is published, it'll trigger release workflow which creates PyPI  release and deploys updated documentation.</p>"},{"location":"#pre-commit","title":"Pre-commit","text":"<p>Pre-commit hooks run all the auto-formatters (e.g. <code>black</code>, <code>isort</code>), linters (e.g. <code>mypy</code>, <code>flake8</code>), and other quality  checks to make sure the changeset is in good shape before a commit/push happens.</p> <p>You can install the hooks with (runs for each commit):</p> <pre><code>pre-commit install\n</code></pre> <p>Or if you want them to run only for each push:</p> <pre><code>pre-commit install -t pre-push\n</code></pre> <p>Or if you want e.g. want to run all checks manually for all files:</p> <pre><code>pre-commit run --all-files\n</code></pre> <p>This project was generated using the wolt-python-package-cookiecutter template.</p>"},{"location":"api_docs/","title":"API documentation","text":""},{"location":"api_docs/#data_samples_printer.making_histograms","title":"<code>making_histograms</code>","text":""},{"location":"api_docs/#data_samples_printer.making_histograms.generate_annotated_hists","title":"<code>generate_annotated_hists(*xs: Sequence[float], max_bins: int = 50, num_bins: Optional[int] = None, min_value: Optional[float] = None, max_value: Optional[float] = None, annotations: Annotations = Annotations(0), **named_xs: Sequence[float]) -&gt; Generator[List[str], None, None]</code>","text":"<p>Yields a histogram with annotations for each set of samples</p> <p>Depending on the style, it yields a header first</p> <p>It will ensure that all histograms are aligned (have the same number of bins and ranges).</p> <p>:param xs: The sets of samples to make histograms from. :param max_bins: The maximum number of bins to use. Determines the maximum length of the histogram string. :param num_bins: The number of bins to use. If None, it will be computed from the data. :param min_value: Where the histogram should start. If None, it will be computed from the data. :param max_value: Where the histogram should end. If None, it will be computed from the data. :param annotations: The annotations to add to each histogram such as  mean/std/min/max/n. :param named_xs: The sets of values to make histograms from. The keys are used as names. :raises ValueError: If num_bins &gt; max_bins or min_value &gt; max_value or both xs and named_xs were specified.</p> Source code in <code>src/data_samples_printer/making_histograms.py</code> <pre><code>def generate_annotated_hists(\n    *xs: Sequence[float],\n    max_bins: int = 50,\n    num_bins: Optional[int] = None,\n    min_value: Optional[float] = None,\n    max_value: Optional[float] = None,\n    annotations: Annotations = Annotations(0),\n    **named_xs: Sequence[float],\n) -&gt; Generator[List[str], None, None]:\n\"\"\"Yields a histogram with annotations for each set of samples\n\n    Depending on the style, it yields a header first\n\n    It will ensure that all histograms are aligned (have the same number of bins and\n    ranges).\n\n    :param xs: The sets of samples to make histograms from.\n    :param max_bins: The maximum number of bins to use. Determines the maximum length\n    of the histogram string.\n    :param num_bins: The number of bins to use. If None, it will be computed from the\n    data.\n    :param min_value: Where the histogram should start. If None, it will be computed\n    from the data.\n    :param max_value: Where the histogram should end. If None, it will be computed from\n    the data.\n    :param annotations: The annotations to add to each histogram such as\n     mean/std/min/max/n.\n    :param named_xs: The sets of values to make histograms from. The keys are used as\n    names.\n    :raises ValueError: If num_bins &gt; max_bins or min_value &gt; max_value\n    or both xs and named_xs were specified.\n    \"\"\"\n    if len(xs) &gt; 0 and len(named_xs) &gt; 0:\n        raise ValueError(\n            f\"Can't have both unnamed and named arguments. \"\n            f\"You passed {xs} and {named_xs}\"\n        )  # pragma: no cover\n\n    names: Sequence[str]\n    if len(named_xs) &gt; 0:\n        xs = cast(Tuple[Sequence[float]], named_xs.values())\n        names = cast(Sequence[str], named_xs.keys())\n        show_names = True\n    else:\n        names = [\"\"] * len(xs)\n        show_names = False\n\n    for x, name, hist_str in zip(\n        xs,\n        names,\n        generate_hists(\n            *xs,\n            max_bins=max_bins,\n            num_bins=num_bins,\n            max_value=max_value,\n            min_value=min_value,\n        ),\n    ):\n        hist_line = [hist_str]\n\n        if Annotations.ADD_MEAN in annotations:\n            hist_line.append(f\"{np.mean(x):.2f}\")\n\n        if Annotations.ADD_STD in annotations:\n            hist_line.append(f\"\u00b1{np.std(x):.2f}\")\n\n        if Annotations.ADD_NUM_VALUES in annotations:\n            hist_line.append(f\"{len(x)}\")\n\n        if show_names:\n            hist_line.append(name)\n\n        yield hist_line\n</code></pre>"},{"location":"api_docs/#data_samples_printer.making_histograms.generate_hists","title":"<code>generate_hists(*xs: Sequence[float], max_bins: int = 50, num_bins: Optional[int] = None, min_value: Optional[float] = None, max_value: Optional[float] = None) -&gt; Generator[str, None, None]</code>","text":"<p>Yields histogram strings for each set of samples.</p> <p>It will ensure that all histograms are aligned (have the same number of bins and ranges).</p> <p>:param xs: The sets of samples to make histograms from. :param max_bins: The maximum number of bins to use. Determines the maximum length of the yielded strings. :param num_bins: The number of bins to use. If None, it will be computed from the data. :param min_value: Where the histogram should start. If None, it will be computed from the data. :param max_value: Where the histogram should end. If None, it will be computed from the data. :raises ValueError: If num_bins &gt; max_bins or min_value &gt; max_value.</p> Source code in <code>src/data_samples_printer/making_histograms.py</code> <pre><code>def generate_hists(\n    *xs: Sequence[float],\n    max_bins: int = 50,\n    num_bins: Optional[int] = None,\n    min_value: Optional[float] = None,\n    max_value: Optional[float] = None,\n) -&gt; Generator[str, None, None]:\n\"\"\"Yields histogram strings for each set of samples.\n\n    It will ensure that all histograms are aligned (have the same number of bins and\n    ranges).\n\n    :param xs: The sets of samples to make histograms from.\n    :param max_bins: The maximum number of bins to use. Determines the maximum length\n    of the yielded strings.\n    :param num_bins: The number of bins to use. If None, it will be computed from the\n    data.\n    :param min_value: Where the histogram should start. If None, it will be computed\n    from the data.\n    :param max_value: Where the histogram should end. If None, it will be computed from\n    the data.\n    :raises ValueError: If num_bins &gt; max_bins or min_value &gt; max_value.\n    \"\"\"\n    if len(xs) == 0:\n        return\n\n    _check_for_sample_sizes_less_than_two(xs)\n\n    num_bins = _deduce_num_bins(xs, max_bins=max_bins, num_bins=num_bins)\n    min_value, max_value = _deduce_range(xs, min_value=min_value, max_value=max_value)\n\n    for x in xs:\n        hist, bin_edges = np.histogram(x, bins=num_bins, range=(min_value, max_value))\n        # scales from [0, max(hist)] to [0, num_drawing_chars-1]\n        max_count = np.max(hist)\n        if max_count == 0:\n            scaling_factor = 0\n        else:\n            scaling_factor = (_NUM_DRAWING_CHARS - 1) / np.max(hist)\n        char_indexes = np.round(hist * scaling_factor).astype(int)\n        yield \"\".join(_DRAWING_CHARS[char_indexes])\n</code></pre>"},{"location":"api_docs/#data_samples_printer.making_histograms.make_header","title":"<code>make_header(annotations: Annotations, add_names_column: bool) -&gt; List[str]</code>","text":"<p>Makes a header with the given annotations to print above annotated histograms.</p> Source code in <code>src/data_samples_printer/making_histograms.py</code> <pre><code>def make_header(annotations: Annotations, add_names_column: bool) -&gt; List[str]:\n\"\"\"Makes a header with the given annotations to print above annotated histograms.\"\"\"\n    header = [\"dist\"]\n\n    if Annotations.ADD_MEAN in annotations:\n        header.append(\"mean\")\n\n    if Annotations.ADD_STD in annotations:\n        header.append(\"std\")\n\n    if Annotations.ADD_NUM_VALUES in annotations:\n        header.append(\"n\")\n\n    if Annotations.ADD_MIN in annotations:\n        header.append(\"min\")\n\n    if Annotations.ADD_MAX in annotations:\n        header.append(\"max\")\n\n    if add_names_column:\n        header.append(\"name\")\n\n    return header\n</code></pre>"},{"location":"api_docs/#data_samples_printer.making_histograms.make_min_max_footer","title":"<code>make_min_max_footer(*xs: Sequence[float], width: int, min_value: Optional[float] = None, max_value: Optional[float] = None, **named_xs: Sequence[float]) -&gt; str</code>","text":"<p>Makes a footer with the min and max values of the given samples.</p> <p>To be printed below and unannotated histogram.</p> <p>:param xs: The sets of samples to make histograms from. :param width: The width of the histogram in chars. :param min_value: Where the histogram should start. If None, it will be computed from the data. :param max_value: Where the histogram should end. If None, it will be computed from the data.</p> Source code in <code>src/data_samples_printer/making_histograms.py</code> <pre><code>def make_min_max_footer(\n    *xs: Sequence[float],\n    width: int,\n    min_value: Optional[float] = None,\n    max_value: Optional[float] = None,\n    **named_xs: Sequence[float],\n) -&gt; str:\n\"\"\"Makes a footer with the min and max values of the given samples.\n\n    To be printed below and unannotated histogram.\n\n    :param xs: The sets of samples to make histograms from.\n    :param width: The width of the histogram in chars.\n    :param min_value: Where the histogram should start. If None, it will be computed\n    from the data.\n    :param max_value: Where the histogram should end. If None, it will be computed from\n    the data.\n    \"\"\"\n    if len(named_xs) &gt; 0:\n        xs = cast(tuple, named_xs.values())\n\n    if len(xs) == 0:\n        return \" \" * width\n\n    min_value, max_value = _deduce_range(xs, min_value=min_value, max_value=max_value)\n\n    min_str = f\"{min_value:.2f}\"\n    max_str = f\"{max_value:.2f}\"\n    return min_str + \" \" * max(1, (width - len(min_str) - len(max_str) - 4)) + max_str\n</code></pre>"},{"location":"api_docs/#data_samples_printer.printing_histograms","title":"<code>printing_histograms</code>","text":""},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>The format is based on Keep a Changelog, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#unreleased","title":"Unreleased","text":""},{"location":"changelog/#001-2023-08-31","title":"0.0.1 - 2023-08-31","text":""},{"location":"changelog/#added","title":"Added","text":"<ul> <li>First draft of package</li> </ul>"}]}